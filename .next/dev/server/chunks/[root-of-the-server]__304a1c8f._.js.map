{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.2.0\",\n  \"engineVersion\": \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\",\n  \"activeProvider\": \"sqlite\",\n  \"inlineSchema\": \"// Flipper.ai Database Schema\\n// Using SQLite for simple, file-based persistence\\n\\ngenerator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../src/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"sqlite\\\"\\n}\\n\\n// Marketplace sources we scrape from\\nenum Platform {\\n  CRAIGSLIST\\n  FACEBOOK_MARKETPLACE\\n  EBAY\\n  OFFERUP\\n}\\n\\n// Status of a listing in our pipeline\\nenum ListingStatus {\\n  NEW // Just scraped\\n  ANALYZING // Calculating flip potential\\n  OPPORTUNITY // Good flip opportunity identified\\n  CONTACTED // Seller has been contacted\\n  PURCHASED // Item purchased\\n  LISTED // Re-listed for sale\\n  SOLD // Successfully flipped\\n  PASSED // Decided to skip\\n  EXPIRED // Listing no longer available\\n}\\n\\n// Raw listings scraped from marketplaces\\nmodel Listing {\\n  id            String    @id @default(cuid())\\n  externalId    String // Original listing ID from the platform\\n  platform      String // CRAIGSLIST, FACEBOOK_MARKETPLACE, EBAY, OFFERUP\\n  url           String\\n  title         String\\n  description   String?\\n  askingPrice   Float\\n  condition     String?\\n  location      String?\\n  sellerName    String?\\n  sellerContact String?\\n  imageUrls     String? // JSON array of image URLs\\n  category      String?\\n  postedAt      DateTime?\\n  scrapedAt     DateTime  @default(now())\\n\\n  // Flip analysis\\n  estimatedValue   Float? // What we think it's worth (midpoint)\\n  estimatedLow     Float? // Low end of estimated value range\\n  estimatedHigh    Float? // High end of estimated value range\\n  profitPotential  Float? // Estimated profit if flipped\\n  profitLow        Float? // Low end profit estimate\\n  profitHigh       Float? // High end profit estimate\\n  valueScore       Float? // 0-100 score of flip potential\\n  discountPercent  Float? // How far below market value (e.g., 40 = 40% below)\\n  resaleDifficulty String? // VERY_EASY, EASY, MODERATE, HARD, VERY_HARD\\n  status           String  @default(\\\"NEW\\\")\\n\\n  // Market references (JSON)\\n  comparableUrls String? // JSON: URLs to eBay sold listings, etc.\\n  priceReasoning String? // Explanation of how value was estimated\\n  notes          String? // AI-generated analysis notes\\n\\n  // Additional metadata for flipping\\n  shippable       Boolean? // Can be shipped (vs local pickup only)\\n  estimatedWeight Float? // Estimated weight in lbs (for shipping cost)\\n  negotiable      Boolean? // Is price negotiable? (detected from OBO, firm, etc.)\\n  daysListed      Int? // Days since originally posted\\n  tags            String? // JSON: Array of detected keywords for filtering\\n\\n  // AI-generated purchase request message\\n  requestToBuy String? // AI-generated message to send to seller\\n\\n  // Relations\\n  opportunity Opportunity?\\n\\n  // Indexes\\n  @@unique([platform, externalId])\\n  @@index([platform])\\n  @@index([status])\\n  @@index([valueScore])\\n  @@index([scrapedAt])\\n}\\n\\n// Flip opportunities we're actively pursuing\\nmodel Opportunity {\\n  id        String  @id @default(cuid())\\n  listingId String  @unique\\n  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)\\n\\n  // Purchase info\\n  purchasePrice Float?\\n  purchaseDate  DateTime?\\n  purchaseNotes String?\\n\\n  // Resale info\\n  resalePrice    Float?\\n  resalePlatform String?\\n  resaleUrl      String?\\n  resaleDate     DateTime?\\n\\n  // Profit tracking\\n  actualProfit Float?\\n  fees         Float? // Platform fees, shipping, etc.\\n\\n  // Status\\n  status String  @default(\\\"IDENTIFIED\\\")\\n  notes  String?\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n\\n  @@index([status])\\n  @@index([createdAt])\\n}\\n\\n// Scraper job runs\\nmodel ScraperJob {\\n  id                 String    @id @default(cuid())\\n  platform           String\\n  location           String?\\n  category           String?\\n  status             String    @default(\\\"PENDING\\\") // PENDING, RUNNING, COMPLETED, FAILED\\n  listingsFound      Int       @default(0)\\n  opportunitiesFound Int       @default(0)\\n  errorMessage       String?\\n  startedAt          DateTime?\\n  completedAt        DateTime?\\n  createdAt          DateTime  @default(now())\\n\\n  @@index([status])\\n  @@index([createdAt])\\n}\\n\\n// Search configurations for automated scraping\\nmodel SearchConfig {\\n  id        String    @id @default(cuid())\\n  name      String\\n  platform  String\\n  location  String\\n  category  String?\\n  keywords  String? // Comma-separated keywords\\n  minPrice  Float?\\n  maxPrice  Float?\\n  enabled   Boolean   @default(true)\\n  lastRun   DateTime?\\n  createdAt DateTime  @default(now())\\n  updatedAt DateTime  @updatedAt\\n\\n  @@index([enabled])\\n}\\n\\n// Price history for market value estimation\\nmodel PriceHistory {\\n  id          String   @id @default(cuid())\\n  productName String\\n  category    String?\\n  platform    String\\n  soldPrice   Float\\n  condition   String?\\n  soldAt      DateTime\\n  createdAt   DateTime @default(now())\\n\\n  @@index([productName])\\n  @@index([category])\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"Listing\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"externalId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"url\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"askingPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"condition\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"sellerName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"sellerContact\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"imageUrls\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"postedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"scrapedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"estimatedValue\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"estimatedLow\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"estimatedHigh\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitPotential\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitLow\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitHigh\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"valueScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"discountPercent\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"resaleDifficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"comparableUrls\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"priceReasoning\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"notes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"shippable\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"estimatedWeight\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"negotiable\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"daysListed\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"tags\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"requestToBuy\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"opportunity\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Opportunity\\\",\\\"relationName\\\":\\\"ListingToOpportunity\\\"}],\\\"dbName\\\":null},\\\"Opportunity\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listingId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listing\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Listing\\\",\\\"relationName\\\":\\\"ListingToOpportunity\\\"},{\\\"name\\\":\\\"purchasePrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"purchaseDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"purchaseNotes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resalePrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"resalePlatform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resaleUrl\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resaleDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"actualProfit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"fees\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"notes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"ScraperJob\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listingsFound\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"opportunitiesFound\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"errorMessage\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"completedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"SearchConfig\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"keywords\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"minPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"maxPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"enabled\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"lastRun\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"PriceHistory\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"productName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"soldPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"condition\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"soldAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_bg.sqlite.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_bg.sqlite.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  }\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Listings\n   * const listings = await prisma.listing.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Listings\n * const listings = await prisma.listing.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Listings\n    * const listings = await prisma.listing.findMany()\n    * ```\n    */\n  get listing(): Prisma.ListingDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Opportunities\n    * const opportunities = await prisma.opportunity.findMany()\n    * ```\n    */\n  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.scraperJob`: Exposes CRUD operations for the **ScraperJob** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ScraperJobs\n    * const scraperJobs = await prisma.scraperJob.findMany()\n    * ```\n    */\n  get scraperJob(): Prisma.ScraperJobDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.searchConfig`: Exposes CRUD operations for the **SearchConfig** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more SearchConfigs\n    * const searchConfigs = await prisma.searchConfig.findMany()\n    * ```\n    */\n  get searchConfig(): Prisma.SearchConfigDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more PriceHistories\n    * const priceHistories = await prisma.priceHistory.findMany()\n    * ```\n    */\n  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":";;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC,GAED;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;AACF;AAsLO,SAAS;IACd,OAAO,udAAuB,CAAC;AACjC"}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.2.0\n * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.2.0\",\n  engine: \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  Listing: 'Listing',\n  Opportunity: 'Opportunity',\n  ScraperJob: 'ScraperJob',\n  SearchConfig: 'SearchConfig',\n  PriceHistory: 'PriceHistory'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"listing\" | \"opportunity\" | \"scraperJob\" | \"searchConfig\" | \"priceHistory\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    Listing: {\n      payload: Prisma.$ListingPayload<ExtArgs>\n      fields: Prisma.ListingFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ListingFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        findFirst: {\n          args: Prisma.ListingFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        findMany: {\n          args: Prisma.ListingFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        create: {\n          args: Prisma.ListingCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        createMany: {\n          args: Prisma.ListingCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        delete: {\n          args: Prisma.ListingDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        update: {\n          args: Prisma.ListingUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        deleteMany: {\n          args: Prisma.ListingDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ListingUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ListingUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        upsert: {\n          args: Prisma.ListingUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        aggregate: {\n          args: Prisma.ListingAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateListing>\n        }\n        groupBy: {\n          args: Prisma.ListingGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ListingGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ListingCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ListingCountAggregateOutputType> | number\n        }\n      }\n    }\n    Opportunity: {\n      payload: Prisma.$OpportunityPayload<ExtArgs>\n      fields: Prisma.OpportunityFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.OpportunityFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        findFirst: {\n          args: Prisma.OpportunityFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        findMany: {\n          args: Prisma.OpportunityFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        create: {\n          args: Prisma.OpportunityCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        createMany: {\n          args: Prisma.OpportunityCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        delete: {\n          args: Prisma.OpportunityDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        update: {\n          args: Prisma.OpportunityUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        deleteMany: {\n          args: Prisma.OpportunityDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.OpportunityUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        upsert: {\n          args: Prisma.OpportunityUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        aggregate: {\n          args: Prisma.OpportunityAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateOpportunity>\n        }\n        groupBy: {\n          args: Prisma.OpportunityGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OpportunityGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.OpportunityCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OpportunityCountAggregateOutputType> | number\n        }\n      }\n    }\n    ScraperJob: {\n      payload: Prisma.$ScraperJobPayload<ExtArgs>\n      fields: Prisma.ScraperJobFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ScraperJobFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ScraperJobFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        findFirst: {\n          args: Prisma.ScraperJobFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ScraperJobFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        findMany: {\n          args: Prisma.ScraperJobFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        create: {\n          args: Prisma.ScraperJobCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        createMany: {\n          args: Prisma.ScraperJobCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ScraperJobCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        delete: {\n          args: Prisma.ScraperJobDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        update: {\n          args: Prisma.ScraperJobUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        deleteMany: {\n          args: Prisma.ScraperJobDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ScraperJobUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ScraperJobUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        upsert: {\n          args: Prisma.ScraperJobUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        aggregate: {\n          args: Prisma.ScraperJobAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateScraperJob>\n        }\n        groupBy: {\n          args: Prisma.ScraperJobGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScraperJobGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ScraperJobCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScraperJobCountAggregateOutputType> | number\n        }\n      }\n    }\n    SearchConfig: {\n      payload: Prisma.$SearchConfigPayload<ExtArgs>\n      fields: Prisma.SearchConfigFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.SearchConfigFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.SearchConfigFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        findFirst: {\n          args: Prisma.SearchConfigFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.SearchConfigFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        findMany: {\n          args: Prisma.SearchConfigFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        create: {\n          args: Prisma.SearchConfigCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        createMany: {\n          args: Prisma.SearchConfigCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.SearchConfigCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        delete: {\n          args: Prisma.SearchConfigDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        update: {\n          args: Prisma.SearchConfigUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        deleteMany: {\n          args: Prisma.SearchConfigDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.SearchConfigUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.SearchConfigUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        upsert: {\n          args: Prisma.SearchConfigUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        aggregate: {\n          args: Prisma.SearchConfigAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateSearchConfig>\n        }\n        groupBy: {\n          args: Prisma.SearchConfigGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SearchConfigGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.SearchConfigCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SearchConfigCountAggregateOutputType> | number\n        }\n      }\n    }\n    PriceHistory: {\n      payload: Prisma.$PriceHistoryPayload<ExtArgs>\n      fields: Prisma.PriceHistoryFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        findFirst: {\n          args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        findMany: {\n          args: Prisma.PriceHistoryFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        create: {\n          args: Prisma.PriceHistoryCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        createMany: {\n          args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        delete: {\n          args: Prisma.PriceHistoryDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        update: {\n          args: Prisma.PriceHistoryUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        deleteMany: {\n          args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.PriceHistoryUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        upsert: {\n          args: Prisma.PriceHistoryUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        aggregate: {\n          args: Prisma.PriceHistoryAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregatePriceHistory>\n        }\n        groupBy: {\n          args: Prisma.PriceHistoryGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.PriceHistoryGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.PriceHistoryCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.PriceHistoryCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const ListingScalarFieldEnum = {\n  id: 'id',\n  externalId: 'externalId',\n  platform: 'platform',\n  url: 'url',\n  title: 'title',\n  description: 'description',\n  askingPrice: 'askingPrice',\n  condition: 'condition',\n  location: 'location',\n  sellerName: 'sellerName',\n  sellerContact: 'sellerContact',\n  imageUrls: 'imageUrls',\n  category: 'category',\n  postedAt: 'postedAt',\n  scrapedAt: 'scrapedAt',\n  estimatedValue: 'estimatedValue',\n  estimatedLow: 'estimatedLow',\n  estimatedHigh: 'estimatedHigh',\n  profitPotential: 'profitPotential',\n  profitLow: 'profitLow',\n  profitHigh: 'profitHigh',\n  valueScore: 'valueScore',\n  discountPercent: 'discountPercent',\n  resaleDifficulty: 'resaleDifficulty',\n  status: 'status',\n  comparableUrls: 'comparableUrls',\n  priceReasoning: 'priceReasoning',\n  notes: 'notes',\n  shippable: 'shippable',\n  estimatedWeight: 'estimatedWeight',\n  negotiable: 'negotiable',\n  daysListed: 'daysListed',\n  tags: 'tags',\n  requestToBuy: 'requestToBuy'\n} as const\n\nexport type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]\n\n\nexport const OpportunityScalarFieldEnum = {\n  id: 'id',\n  listingId: 'listingId',\n  purchasePrice: 'purchasePrice',\n  purchaseDate: 'purchaseDate',\n  purchaseNotes: 'purchaseNotes',\n  resalePrice: 'resalePrice',\n  resalePlatform: 'resalePlatform',\n  resaleUrl: 'resaleUrl',\n  resaleDate: 'resaleDate',\n  actualProfit: 'actualProfit',\n  fees: 'fees',\n  status: 'status',\n  notes: 'notes',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]\n\n\nexport const ScraperJobScalarFieldEnum = {\n  id: 'id',\n  platform: 'platform',\n  location: 'location',\n  category: 'category',\n  status: 'status',\n  listingsFound: 'listingsFound',\n  opportunitiesFound: 'opportunitiesFound',\n  errorMessage: 'errorMessage',\n  startedAt: 'startedAt',\n  completedAt: 'completedAt',\n  createdAt: 'createdAt'\n} as const\n\nexport type ScraperJobScalarFieldEnum = (typeof ScraperJobScalarFieldEnum)[keyof typeof ScraperJobScalarFieldEnum]\n\n\nexport const SearchConfigScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  platform: 'platform',\n  location: 'location',\n  category: 'category',\n  keywords: 'keywords',\n  minPrice: 'minPrice',\n  maxPrice: 'maxPrice',\n  enabled: 'enabled',\n  lastRun: 'lastRun',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type SearchConfigScalarFieldEnum = (typeof SearchConfigScalarFieldEnum)[keyof typeof SearchConfigScalarFieldEnum]\n\n\nexport const PriceHistoryScalarFieldEnum = {\n  id: 'id',\n  productName: 'productName',\n  category: 'category',\n  platform: 'platform',\n  soldPrice: 'soldPrice',\n  condition: 'condition',\n  soldAt: 'soldAt',\n  createdAt: 'createdAt'\n} as const\n\nexport type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  listing?: Prisma.ListingOmit\n  opportunity?: Prisma.OpportunityOmit\n  scraperJob?: Prisma.ScraperJobOmit\n  searchConfig?: Prisma.SearchConfigOmit\n  priceHistory?: Prisma.PriceHistoryOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;;;;;CAUC,GAED;;AAcO,MAAM,gCAAgC,qeAAqC;AAG3E,MAAM,kCAAkC,ueAAuC;AAG/E,MAAM,6BAA6B,keAAkC;AAGrE,MAAM,kCAAkC,ueAAuC;AAG/E,MAAM,8BAA8B,meAAmC;AAMvE,MAAM,MAAM,8cAAc;AAC1B,MAAM,QAAQ,6cAAa;AAC3B,MAAM,OAAO,4cAAY;AACzB,MAAM,MAAM,2cAAW;AACvB,MAAM,MAAM,2cAAW;AAQvB,MAAM,UAAU,+cAAe;AAS/B,MAAM,sBAAsB,kdAAkB,CAAC,mBAAmB;AAelE,MAAM,gBAA+B;IAC1C,QAAQ;IACR,QAAQ;AACV;AAeO,MAAM,YAAY;IACvB,QAAQ,idAAiB,CAAC,MAAM;IAChC,UAAU,idAAiB,CAAC,QAAQ;IACpC,SAAS,idAAiB,CAAC,OAAO;AACpC;AAMO,MAAM,SAAS,8cAAc;AAO7B,MAAM,WAAW,gdAAgB;AAOjC,MAAM,UAAU,+cAAe;AAkQ/B,MAAM,YAAY;IACvB,SAAS;IACT,aAAa;IACb,YAAY;IACZ,cAAc;IACd,cAAc;AAChB;AAkaO,MAAM,4BAA4B,sdAAsB,CAAC;IAC9D,cAAc;AAChB;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,YAAY;IACZ,UAAU;IACV,KAAK;IACL,OAAO;IACP,aAAa;IACb,aAAa;IACb,WAAW;IACX,UAAU;IACV,YAAY;IACZ,eAAe;IACf,WAAW;IACX,UAAU;IACV,UAAU;IACV,WAAW;IACX,gBAAgB;IAChB,cAAc;IACd,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,QAAQ;IACR,gBAAgB;IAChB,gBAAgB;IAChB,OAAO;IACP,WAAW;IACX,iBAAiB;IACjB,YAAY;IACZ,YAAY;IACZ,MAAM;IACN,cAAc;AAChB;AAKO,MAAM,6BAA6B;IACxC,IAAI;IACJ,WAAW;IACX,eAAe;IACf,cAAc;IACd,eAAe;IACf,aAAa;IACb,gBAAgB;IAChB,WAAW;IACX,YAAY;IACZ,cAAc;IACd,MAAM;IACN,QAAQ;IACR,OAAO;IACP,WAAW;IACX,WAAW;AACb;AAKO,MAAM,4BAA4B;IACvC,IAAI;IACJ,UAAU;IACV,UAAU;IACV,UAAU;IACV,QAAQ;IACR,eAAe;IACf,oBAAoB;IACpB,cAAc;IACd,WAAW;IACX,aAAa;IACb,WAAW;AACb;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,MAAM;IACN,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;AACb;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,aAAa;IACb,UAAU;IACV,UAAU;IACV,WAAW;IACX,WAAW;IACX,QAAQ;IACR,WAAW;AACb;AAKO,MAAM,YAAY;IACvB,KAAK;IACL,MAAM;AACR;AAKO,MAAM,aAAa;IACxB,OAAO;IACP,MAAM;AACR;AAoDO,MAAM,kBAAkB,kdAAkB,CAAC,eAAe"}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\nexport const Platform = {\n  CRAIGSLIST: 'CRAIGSLIST',\n  FACEBOOK_MARKETPLACE: 'FACEBOOK_MARKETPLACE',\n  EBAY: 'EBAY',\n  OFFERUP: 'OFFERUP'\n} as const\n\nexport type Platform = (typeof Platform)[keyof typeof Platform]\n\n\nexport const ListingStatus = {\n  NEW: 'NEW',\n  ANALYZING: 'ANALYZING',\n  OPPORTUNITY: 'OPPORTUNITY',\n  CONTACTED: 'CONTACTED',\n  PURCHASED: 'PURCHASED',\n  LISTED: 'LISTED',\n  SOLD: 'SOLD',\n  PASSED: 'PASSED',\n  EXPIRED: 'EXPIRED'\n} as const\n\nexport type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA;;;;;;AAEO,MAAM,WAAW;IACtB,YAAY;IACZ,sBAAsB;IACtB,MAAM;IACN,SAAS;AACX;AAKO,MAAM,gBAAgB;IAC3B,KAAK;IACL,WAAW;IACX,aAAa;IACb,WAAW;IACX,WAAW;IACX,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,SAAS;AACX"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Listings\n * const listings = await prisma.listing.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model Listing\n * \n */\nexport type Listing = Prisma.ListingModel\n/**\n * Model Opportunity\n * \n */\nexport type Opportunity = Prisma.OpportunityModel\n/**\n * Model ScraperJob\n * \n */\nexport type ScraperJob = Prisma.ScraperJobModel\n/**\n * Model SearchConfig\n * \n */\nexport type SearchConfig = Prisma.SearchConfigModel\n/**\n * Model PriceHistory\n * \n */\nexport type PriceHistory = Prisma.PriceHistoryModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAGD;AACA;AAKA;AACA;AAEA;;;;;;;;AAPA,UAAU,CAAC,YAAY,GAAG,4HAAY,CAAC,IAAA,gIAAa,EAAC,8BAAY,GAAG;;;;;AAsB7D,MAAM,eAAe,0LAA2B"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@/generated/prisma/client\";\nimport { PrismaLibSql } from \"@prisma/adapter-libsql\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nconst defaultDatabaseUrl = \"file:./dev.db\";\n\nfunction resolveDatabaseUrl() {\n  return process.env.DATABASE_URL ?? defaultDatabaseUrl;\n}\n\nfunction createPrismaClient() {\n  const adapter = new PrismaLibSql({\n    url: resolveDatabaseUrl(),\n  });\n  return new PrismaClient({ adapter });\n}\n\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,qBAAqB;AAE3B,SAAS;IACP,OAAO,QAAQ,GAAG,CAAC,YAAY,IAAI;AACrC;AAEA,SAAS;IACP,MAAM,UAAU,IAAI,8SAAY,CAAC;QAC/B,KAAK;IACP;IACA,OAAO,IAAI,uLAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 411, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/app/api/scraper-jobs/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/db\";\n\n// GET /api/scraper-jobs - List all scraper jobs\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const status = searchParams.get(\"status\");\n    const platform = searchParams.get(\"platform\");\n    const limit = parseInt(searchParams.get(\"limit\") || \"50\");\n\n    const where: Record<string, unknown> = {};\n    if (status) where.status = status;\n    if (platform) where.platform = platform;\n\n    const jobs = await prisma.scraperJob.findMany({\n      where,\n      orderBy: { createdAt: \"desc\" },\n      take: limit,\n    });\n\n    return NextResponse.json({\n      jobs,\n      total: jobs.length,\n    });\n  } catch (error) {\n    console.error(\"Error fetching scraper jobs:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch scraper jobs\" },\n      { status: 500 }\n    );\n  }\n}\n\n// POST /api/scraper-jobs - Create a new scraper job\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { platform, location, category } = body;\n\n    // Validate required fields\n    if (!platform) {\n      return NextResponse.json(\n        { error: \"Platform is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate platform\n    const validPlatforms = [\"CRAIGSLIST\", \"FACEBOOK_MARKETPLACE\", \"EBAY\", \"OFFERUP\"];\n    if (!validPlatforms.includes(platform)) {\n      return NextResponse.json(\n        { error: `Invalid platform. Must be one of: ${validPlatforms.join(\", \")}` },\n        { status: 400 }\n      );\n    }\n\n    const job = await prisma.scraperJob.create({\n      data: {\n        platform,\n        location: location || null,\n        category: category || null,\n        status: \"PENDING\",\n      },\n    });\n\n    return NextResponse.json(job, { status: 201 });\n  } catch (error) {\n    console.error(\"Error creating scraper job:\", error);\n    return NextResponse.json(\n      { error: \"Failed to create scraper job\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,WAAW,aAAa,GAAG,CAAC;QAClC,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QAEpD,MAAM,QAAiC,CAAC;QACxC,IAAI,QAAQ,MAAM,MAAM,GAAG;QAC3B,IAAI,UAAU,MAAM,QAAQ,GAAG;QAE/B,MAAM,OAAO,MAAM,8IAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;YAC5C;YACA,SAAS;gBAAE,WAAW;YAAO;YAC7B,MAAM;QACR;QAEA,OAAO,gXAAY,CAAC,IAAI,CAAC;YACvB;YACA,OAAO,KAAK,MAAM;QACpB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gXAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG;QAEzC,2BAA2B;QAC3B,IAAI,CAAC,UAAU;YACb,OAAO,gXAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAuB,GAChC;gBAAE,QAAQ;YAAI;QAElB;QAEA,oBAAoB;QACpB,MAAM,iBAAiB;YAAC;YAAc;YAAwB;YAAQ;SAAU;QAChF,IAAI,CAAC,eAAe,QAAQ,CAAC,WAAW;YACtC,OAAO,gXAAY,CAAC,IAAI,CACtB;gBAAE,OAAO,CAAC,kCAAkC,EAAE,eAAe,IAAI,CAAC,OAAO;YAAC,GAC1E;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,MAAM,MAAM,8IAAM,CAAC,UAAU,CAAC,MAAM,CAAC;YACzC,MAAM;gBACJ;gBACA,UAAU,YAAY;gBACtB,UAAU,YAAY;gBACtB,QAAQ;YACV;QACF;QAEA,OAAO,gXAAY,CAAC,IAAI,CAAC,KAAK;YAAE,QAAQ;QAAI;IAC9C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gXAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}