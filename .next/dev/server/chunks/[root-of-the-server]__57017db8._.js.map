{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.2.0\",\n  \"engineVersion\": \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\",\n  \"activeProvider\": \"sqlite\",\n  \"inlineSchema\": \"// Flipper.ai Database Schema\\n// Using SQLite for simple, file-based persistence\\n\\ngenerator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../src/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"sqlite\\\"\\n}\\n\\n// Marketplace sources we scrape from\\nenum Platform {\\n  CRAIGSLIST\\n  FACEBOOK_MARKETPLACE\\n  EBAY\\n  OFFERUP\\n}\\n\\n// Status of a listing in our pipeline\\nenum ListingStatus {\\n  NEW // Just scraped\\n  ANALYZING // Calculating flip potential\\n  OPPORTUNITY // Good flip opportunity identified\\n  CONTACTED // Seller has been contacted\\n  PURCHASED // Item purchased\\n  LISTED // Re-listed for sale\\n  SOLD // Successfully flipped\\n  PASSED // Decided to skip\\n  EXPIRED // Listing no longer available\\n}\\n\\n// Raw listings scraped from marketplaces\\nmodel Listing {\\n  id            String    @id @default(cuid())\\n  externalId    String // Original listing ID from the platform\\n  platform      String // CRAIGSLIST, FACEBOOK_MARKETPLACE, EBAY, OFFERUP\\n  url           String\\n  title         String\\n  description   String?\\n  askingPrice   Float\\n  condition     String?\\n  location      String?\\n  sellerName    String?\\n  sellerContact String?\\n  imageUrls     String? // JSON array of image URLs\\n  category      String?\\n  postedAt      DateTime?\\n  scrapedAt     DateTime  @default(now())\\n\\n  // Flip analysis\\n  estimatedValue   Float? // What we think it's worth (midpoint)\\n  estimatedLow     Float? // Low end of estimated value range\\n  estimatedHigh    Float? // High end of estimated value range\\n  profitPotential  Float? // Estimated profit if flipped\\n  profitLow        Float? // Low end profit estimate\\n  profitHigh       Float? // High end profit estimate\\n  valueScore       Float? // 0-100 score of flip potential\\n  discountPercent  Float? // How far below market value (e.g., 40 = 40% below)\\n  resaleDifficulty String? // VERY_EASY, EASY, MODERATE, HARD, VERY_HARD\\n  status           String  @default(\\\"NEW\\\")\\n\\n  // Market references (JSON)\\n  comparableUrls String? // JSON: URLs to eBay sold listings, etc.\\n  priceReasoning String? // Explanation of how value was estimated\\n  notes          String? // AI-generated analysis notes\\n\\n  // Additional metadata for flipping\\n  shippable       Boolean? // Can be shipped (vs local pickup only)\\n  estimatedWeight Float? // Estimated weight in lbs (for shipping cost)\\n  negotiable      Boolean? // Is price negotiable? (detected from OBO, firm, etc.)\\n  daysListed      Int? // Days since originally posted\\n  tags            String? // JSON: Array of detected keywords for filtering\\n\\n  // AI-generated purchase request message\\n  requestToBuy String? // AI-generated message to send to seller\\n\\n  // Relations\\n  opportunity Opportunity?\\n\\n  // Indexes\\n  @@unique([platform, externalId])\\n  @@index([platform])\\n  @@index([status])\\n  @@index([valueScore])\\n  @@index([scrapedAt])\\n}\\n\\n// Flip opportunities we're actively pursuing\\nmodel Opportunity {\\n  id        String  @id @default(cuid())\\n  listingId String  @unique\\n  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)\\n\\n  // Purchase info\\n  purchasePrice Float?\\n  purchaseDate  DateTime?\\n  purchaseNotes String?\\n\\n  // Resale info\\n  resalePrice    Float?\\n  resalePlatform String?\\n  resaleUrl      String?\\n  resaleDate     DateTime?\\n\\n  // Profit tracking\\n  actualProfit Float?\\n  fees         Float? // Platform fees, shipping, etc.\\n\\n  // Status\\n  status String  @default(\\\"IDENTIFIED\\\")\\n  notes  String?\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n\\n  @@index([status])\\n  @@index([createdAt])\\n}\\n\\n// Scraper job runs\\nmodel ScraperJob {\\n  id                 String    @id @default(cuid())\\n  platform           String\\n  location           String?\\n  category           String?\\n  status             String    @default(\\\"PENDING\\\") // PENDING, RUNNING, COMPLETED, FAILED\\n  listingsFound      Int       @default(0)\\n  opportunitiesFound Int       @default(0)\\n  errorMessage       String?\\n  startedAt          DateTime?\\n  completedAt        DateTime?\\n  createdAt          DateTime  @default(now())\\n\\n  @@index([status])\\n  @@index([createdAt])\\n}\\n\\n// Search configurations for automated scraping\\nmodel SearchConfig {\\n  id        String    @id @default(cuid())\\n  name      String\\n  platform  String\\n  location  String\\n  category  String?\\n  keywords  String? // Comma-separated keywords\\n  minPrice  Float?\\n  maxPrice  Float?\\n  enabled   Boolean   @default(true)\\n  lastRun   DateTime?\\n  createdAt DateTime  @default(now())\\n  updatedAt DateTime  @updatedAt\\n\\n  @@index([enabled])\\n}\\n\\n// Price history for market value estimation\\nmodel PriceHistory {\\n  id          String   @id @default(cuid())\\n  productName String\\n  category    String?\\n  platform    String\\n  soldPrice   Float\\n  condition   String?\\n  soldAt      DateTime\\n  createdAt   DateTime @default(now())\\n\\n  @@index([productName])\\n  @@index([category])\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"Listing\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"externalId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"url\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"askingPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"condition\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"sellerName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"sellerContact\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"imageUrls\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"postedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"scrapedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"estimatedValue\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"estimatedLow\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"estimatedHigh\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitPotential\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitLow\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"profitHigh\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"valueScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"discountPercent\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"resaleDifficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"comparableUrls\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"priceReasoning\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"notes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"shippable\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"estimatedWeight\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"negotiable\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"daysListed\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"tags\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"requestToBuy\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"opportunity\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Opportunity\\\",\\\"relationName\\\":\\\"ListingToOpportunity\\\"}],\\\"dbName\\\":null},\\\"Opportunity\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listingId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listing\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Listing\\\",\\\"relationName\\\":\\\"ListingToOpportunity\\\"},{\\\"name\\\":\\\"purchasePrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"purchaseDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"purchaseNotes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resalePrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"resalePlatform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resaleUrl\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"resaleDate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"actualProfit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"fees\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"notes\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"ScraperJob\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"listingsFound\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"opportunitiesFound\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"errorMessage\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"completedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"SearchConfig\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"location\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"keywords\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"minPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"maxPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"enabled\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"lastRun\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"PriceHistory\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"productName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"platform\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"soldPrice\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"condition\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"soldAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_bg.sqlite.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_bg.sqlite.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  }\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Listings\n   * const listings = await prisma.listing.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Listings\n * const listings = await prisma.listing.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Listings\n    * const listings = await prisma.listing.findMany()\n    * ```\n    */\n  get listing(): Prisma.ListingDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Opportunities\n    * const opportunities = await prisma.opportunity.findMany()\n    * ```\n    */\n  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.scraperJob`: Exposes CRUD operations for the **ScraperJob** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ScraperJobs\n    * const scraperJobs = await prisma.scraperJob.findMany()\n    * ```\n    */\n  get scraperJob(): Prisma.ScraperJobDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.searchConfig`: Exposes CRUD operations for the **SearchConfig** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more SearchConfigs\n    * const searchConfigs = await prisma.searchConfig.findMany()\n    * ```\n    */\n  get searchConfig(): Prisma.SearchConfigDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more PriceHistories\n    * const priceHistories = await prisma.priceHistory.findMany()\n    * ```\n    */\n  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":";;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC,GAED;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;AACF;AAsLO,SAAS;IACd,OAAO,scAAuB,CAAC;AACjC"}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.2.0\n * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.2.0\",\n  engine: \"0c8ef2ce45c83248ab3df073180d5eda9e8be7a3\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  Listing: 'Listing',\n  Opportunity: 'Opportunity',\n  ScraperJob: 'ScraperJob',\n  SearchConfig: 'SearchConfig',\n  PriceHistory: 'PriceHistory'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"listing\" | \"opportunity\" | \"scraperJob\" | \"searchConfig\" | \"priceHistory\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    Listing: {\n      payload: Prisma.$ListingPayload<ExtArgs>\n      fields: Prisma.ListingFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ListingFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        findFirst: {\n          args: Prisma.ListingFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        findMany: {\n          args: Prisma.ListingFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        create: {\n          args: Prisma.ListingCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        createMany: {\n          args: Prisma.ListingCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        delete: {\n          args: Prisma.ListingDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        update: {\n          args: Prisma.ListingUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        deleteMany: {\n          args: Prisma.ListingDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ListingUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ListingUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>[]\n        }\n        upsert: {\n          args: Prisma.ListingUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ListingPayload>\n        }\n        aggregate: {\n          args: Prisma.ListingAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateListing>\n        }\n        groupBy: {\n          args: Prisma.ListingGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ListingGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ListingCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ListingCountAggregateOutputType> | number\n        }\n      }\n    }\n    Opportunity: {\n      payload: Prisma.$OpportunityPayload<ExtArgs>\n      fields: Prisma.OpportunityFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.OpportunityFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        findFirst: {\n          args: Prisma.OpportunityFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        findMany: {\n          args: Prisma.OpportunityFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        create: {\n          args: Prisma.OpportunityCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        createMany: {\n          args: Prisma.OpportunityCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        delete: {\n          args: Prisma.OpportunityDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        update: {\n          args: Prisma.OpportunityUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        deleteMany: {\n          args: Prisma.OpportunityDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.OpportunityUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>[]\n        }\n        upsert: {\n          args: Prisma.OpportunityUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$OpportunityPayload>\n        }\n        aggregate: {\n          args: Prisma.OpportunityAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateOpportunity>\n        }\n        groupBy: {\n          args: Prisma.OpportunityGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OpportunityGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.OpportunityCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.OpportunityCountAggregateOutputType> | number\n        }\n      }\n    }\n    ScraperJob: {\n      payload: Prisma.$ScraperJobPayload<ExtArgs>\n      fields: Prisma.ScraperJobFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ScraperJobFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ScraperJobFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        findFirst: {\n          args: Prisma.ScraperJobFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ScraperJobFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        findMany: {\n          args: Prisma.ScraperJobFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        create: {\n          args: Prisma.ScraperJobCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        createMany: {\n          args: Prisma.ScraperJobCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ScraperJobCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        delete: {\n          args: Prisma.ScraperJobDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        update: {\n          args: Prisma.ScraperJobUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        deleteMany: {\n          args: Prisma.ScraperJobDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ScraperJobUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ScraperJobUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>[]\n        }\n        upsert: {\n          args: Prisma.ScraperJobUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScraperJobPayload>\n        }\n        aggregate: {\n          args: Prisma.ScraperJobAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateScraperJob>\n        }\n        groupBy: {\n          args: Prisma.ScraperJobGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScraperJobGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ScraperJobCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScraperJobCountAggregateOutputType> | number\n        }\n      }\n    }\n    SearchConfig: {\n      payload: Prisma.$SearchConfigPayload<ExtArgs>\n      fields: Prisma.SearchConfigFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.SearchConfigFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.SearchConfigFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        findFirst: {\n          args: Prisma.SearchConfigFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.SearchConfigFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        findMany: {\n          args: Prisma.SearchConfigFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        create: {\n          args: Prisma.SearchConfigCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        createMany: {\n          args: Prisma.SearchConfigCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.SearchConfigCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        delete: {\n          args: Prisma.SearchConfigDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        update: {\n          args: Prisma.SearchConfigUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        deleteMany: {\n          args: Prisma.SearchConfigDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.SearchConfigUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.SearchConfigUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>[]\n        }\n        upsert: {\n          args: Prisma.SearchConfigUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$SearchConfigPayload>\n        }\n        aggregate: {\n          args: Prisma.SearchConfigAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateSearchConfig>\n        }\n        groupBy: {\n          args: Prisma.SearchConfigGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SearchConfigGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.SearchConfigCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.SearchConfigCountAggregateOutputType> | number\n        }\n      }\n    }\n    PriceHistory: {\n      payload: Prisma.$PriceHistoryPayload<ExtArgs>\n      fields: Prisma.PriceHistoryFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        findFirst: {\n          args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        findMany: {\n          args: Prisma.PriceHistoryFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        create: {\n          args: Prisma.PriceHistoryCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        createMany: {\n          args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        delete: {\n          args: Prisma.PriceHistoryDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        update: {\n          args: Prisma.PriceHistoryUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        deleteMany: {\n          args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.PriceHistoryUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]\n        }\n        upsert: {\n          args: Prisma.PriceHistoryUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$PriceHistoryPayload>\n        }\n        aggregate: {\n          args: Prisma.PriceHistoryAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregatePriceHistory>\n        }\n        groupBy: {\n          args: Prisma.PriceHistoryGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.PriceHistoryGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.PriceHistoryCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.PriceHistoryCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const ListingScalarFieldEnum = {\n  id: 'id',\n  externalId: 'externalId',\n  platform: 'platform',\n  url: 'url',\n  title: 'title',\n  description: 'description',\n  askingPrice: 'askingPrice',\n  condition: 'condition',\n  location: 'location',\n  sellerName: 'sellerName',\n  sellerContact: 'sellerContact',\n  imageUrls: 'imageUrls',\n  category: 'category',\n  postedAt: 'postedAt',\n  scrapedAt: 'scrapedAt',\n  estimatedValue: 'estimatedValue',\n  estimatedLow: 'estimatedLow',\n  estimatedHigh: 'estimatedHigh',\n  profitPotential: 'profitPotential',\n  profitLow: 'profitLow',\n  profitHigh: 'profitHigh',\n  valueScore: 'valueScore',\n  discountPercent: 'discountPercent',\n  resaleDifficulty: 'resaleDifficulty',\n  status: 'status',\n  comparableUrls: 'comparableUrls',\n  priceReasoning: 'priceReasoning',\n  notes: 'notes',\n  shippable: 'shippable',\n  estimatedWeight: 'estimatedWeight',\n  negotiable: 'negotiable',\n  daysListed: 'daysListed',\n  tags: 'tags',\n  requestToBuy: 'requestToBuy'\n} as const\n\nexport type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]\n\n\nexport const OpportunityScalarFieldEnum = {\n  id: 'id',\n  listingId: 'listingId',\n  purchasePrice: 'purchasePrice',\n  purchaseDate: 'purchaseDate',\n  purchaseNotes: 'purchaseNotes',\n  resalePrice: 'resalePrice',\n  resalePlatform: 'resalePlatform',\n  resaleUrl: 'resaleUrl',\n  resaleDate: 'resaleDate',\n  actualProfit: 'actualProfit',\n  fees: 'fees',\n  status: 'status',\n  notes: 'notes',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]\n\n\nexport const ScraperJobScalarFieldEnum = {\n  id: 'id',\n  platform: 'platform',\n  location: 'location',\n  category: 'category',\n  status: 'status',\n  listingsFound: 'listingsFound',\n  opportunitiesFound: 'opportunitiesFound',\n  errorMessage: 'errorMessage',\n  startedAt: 'startedAt',\n  completedAt: 'completedAt',\n  createdAt: 'createdAt'\n} as const\n\nexport type ScraperJobScalarFieldEnum = (typeof ScraperJobScalarFieldEnum)[keyof typeof ScraperJobScalarFieldEnum]\n\n\nexport const SearchConfigScalarFieldEnum = {\n  id: 'id',\n  name: 'name',\n  platform: 'platform',\n  location: 'location',\n  category: 'category',\n  keywords: 'keywords',\n  minPrice: 'minPrice',\n  maxPrice: 'maxPrice',\n  enabled: 'enabled',\n  lastRun: 'lastRun',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type SearchConfigScalarFieldEnum = (typeof SearchConfigScalarFieldEnum)[keyof typeof SearchConfigScalarFieldEnum]\n\n\nexport const PriceHistoryScalarFieldEnum = {\n  id: 'id',\n  productName: 'productName',\n  category: 'category',\n  platform: 'platform',\n  soldPrice: 'soldPrice',\n  condition: 'condition',\n  soldAt: 'soldAt',\n  createdAt: 'createdAt'\n} as const\n\nexport type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  listing?: Prisma.ListingOmit\n  opportunity?: Prisma.OpportunityOmit\n  scraperJob?: Prisma.ScraperJobOmit\n  searchConfig?: Prisma.SearchConfigOmit\n  priceHistory?: Prisma.PriceHistoryOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;;;;;CAUC,GAED;;AAcO,MAAM,gCAAgC,odAAqC;AAG3E,MAAM,kCAAkC,sdAAuC;AAG/E,MAAM,6BAA6B,idAAkC;AAGrE,MAAM,kCAAkC,sdAAuC;AAG/E,MAAM,8BAA8B,kdAAmC;AAMvE,MAAM,MAAM,6bAAc;AAC1B,MAAM,QAAQ,4bAAa;AAC3B,MAAM,OAAO,2bAAY;AACzB,MAAM,MAAM,0bAAW;AACvB,MAAM,MAAM,0bAAW;AAQvB,MAAM,UAAU,8bAAe;AAS/B,MAAM,sBAAsB,icAAkB,CAAC,mBAAmB;AAelE,MAAM,gBAA+B;IAC1C,QAAQ;IACR,QAAQ;AACV;AAeO,MAAM,YAAY;IACvB,QAAQ,gcAAiB,CAAC,MAAM;IAChC,UAAU,gcAAiB,CAAC,QAAQ;IACpC,SAAS,gcAAiB,CAAC,OAAO;AACpC;AAMO,MAAM,SAAS,6bAAc;AAO7B,MAAM,WAAW,+bAAgB;AAOjC,MAAM,UAAU,8bAAe;AAkQ/B,MAAM,YAAY;IACvB,SAAS;IACT,aAAa;IACb,YAAY;IACZ,cAAc;IACd,cAAc;AAChB;AAkaO,MAAM,4BAA4B,qcAAsB,CAAC;IAC9D,cAAc;AAChB;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,YAAY;IACZ,UAAU;IACV,KAAK;IACL,OAAO;IACP,aAAa;IACb,aAAa;IACb,WAAW;IACX,UAAU;IACV,YAAY;IACZ,eAAe;IACf,WAAW;IACX,UAAU;IACV,UAAU;IACV,WAAW;IACX,gBAAgB;IAChB,cAAc;IACd,eAAe;IACf,iBAAiB;IACjB,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,kBAAkB;IAClB,QAAQ;IACR,gBAAgB;IAChB,gBAAgB;IAChB,OAAO;IACP,WAAW;IACX,iBAAiB;IACjB,YAAY;IACZ,YAAY;IACZ,MAAM;IACN,cAAc;AAChB;AAKO,MAAM,6BAA6B;IACxC,IAAI;IACJ,WAAW;IACX,eAAe;IACf,cAAc;IACd,eAAe;IACf,aAAa;IACb,gBAAgB;IAChB,WAAW;IACX,YAAY;IACZ,cAAc;IACd,MAAM;IACN,QAAQ;IACR,OAAO;IACP,WAAW;IACX,WAAW;AACb;AAKO,MAAM,4BAA4B;IACvC,IAAI;IACJ,UAAU;IACV,UAAU;IACV,UAAU;IACV,QAAQ;IACR,eAAe;IACf,oBAAoB;IACpB,cAAc;IACd,WAAW;IACX,aAAa;IACb,WAAW;AACb;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,MAAM;IACN,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,UAAU;IACV,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;AACb;AAKO,MAAM,8BAA8B;IACzC,IAAI;IACJ,aAAa;IACb,UAAU;IACV,UAAU;IACV,WAAW;IACX,WAAW;IACX,QAAQ;IACR,WAAW;AACb;AAKO,MAAM,YAAY;IACvB,KAAK;IACL,MAAM;AACR;AAKO,MAAM,aAAa;IACxB,OAAO;IACP,MAAM;AACR;AAoDO,MAAM,kBAAkB,icAAkB,CAAC,eAAe"}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\nexport const Platform = {\n  CRAIGSLIST: 'CRAIGSLIST',\n  FACEBOOK_MARKETPLACE: 'FACEBOOK_MARKETPLACE',\n  EBAY: 'EBAY',\n  OFFERUP: 'OFFERUP'\n} as const\n\nexport type Platform = (typeof Platform)[keyof typeof Platform]\n\n\nexport const ListingStatus = {\n  NEW: 'NEW',\n  ANALYZING: 'ANALYZING',\n  OPPORTUNITY: 'OPPORTUNITY',\n  CONTACTED: 'CONTACTED',\n  PURCHASED: 'PURCHASED',\n  LISTED: 'LISTED',\n  SOLD: 'SOLD',\n  PASSED: 'PASSED',\n  EXPIRED: 'EXPIRED'\n} as const\n\nexport type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA;;;;;;AAEO,MAAM,WAAW;IACtB,YAAY;IACZ,sBAAsB;IACtB,MAAM;IACN,SAAS;AACX;AAKO,MAAM,gBAAgB;IAC3B,KAAK;IACL,WAAW;IACX,aAAa;IACb,WAAW;IACX,WAAW;IACX,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,SAAS;AACX"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Listings\n * const listings = await prisma.listing.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model Listing\n * \n */\nexport type Listing = Prisma.ListingModel\n/**\n * Model Opportunity\n * \n */\nexport type Opportunity = Prisma.OpportunityModel\n/**\n * Model ScraperJob\n * \n */\nexport type ScraperJob = Prisma.ScraperJobModel\n/**\n * Model SearchConfig\n * \n */\nexport type SearchConfig = Prisma.SearchConfigModel\n/**\n * Model PriceHistory\n * \n */\nexport type PriceHistory = Prisma.PriceHistoryModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAGD;AACA;AAKA;AACA;AAEA;;;;;;;;AAPA,UAAU,CAAC,YAAY,GAAG,4HAAY,CAAC,IAAA,gIAAa,EAAC,8BAAY,GAAG;;;;;AAsB7D,MAAM,eAAe,yKAA2B"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@/generated/prisma/client\";\nimport { PrismaLibSql } from \"@prisma/adapter-libsql\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nconst defaultDatabaseUrl = \"file:./dev.db\";\n\nfunction resolveDatabaseUrl() {\n  return process.env.DATABASE_URL ?? defaultDatabaseUrl;\n}\n\nfunction createPrismaClient() {\n  const adapter = new PrismaLibSql({\n    url: resolveDatabaseUrl(),\n  });\n  return new PrismaClient({ adapter });\n}\n\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,qBAAqB;AAE3B,SAAS;IACP,OAAO,QAAQ,GAAG,CAAC,YAAY,IAAI;AACrC;AAEA,SAAS;IACP,MAAM,UAAU,IAAI,6RAAY,CAAC;QAC/B,KAAK;IACP;IACA,OAAO,IAAI,sKAAY,CAAC;QAAE;IAAQ;AACpC;AAEO,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/lib/value-estimator.ts"],"sourcesContent":["// Value estimation logic for flip opportunities\n// Uses keyword matching, category-based multipliers, and generates reference links\n\nexport interface EstimationResult {\n  estimatedValue: number;\n  estimatedLow: number;\n  estimatedHigh: number;\n  profitPotential: number;\n  profitLow: number;\n  profitHigh: number;\n  valueScore: number;\n  discountPercent: number;\n  resaleDifficulty: \"VERY_EASY\" | \"EASY\" | \"MODERATE\" | \"HARD\" | \"VERY_HARD\";\n  confidence: \"low\" | \"medium\" | \"high\";\n  reasoning: string;\n  notes: string;\n  comparableUrls: ComparableUrl[];\n  shippable: boolean;\n  negotiable: boolean;\n  tags: string[];\n}\n\nexport interface ComparableUrl {\n  platform: string;\n  label: string;\n  url: string;\n  type: \"sold\" | \"active\" | \"search\";\n}\n\n// Common product categories with typical resale markup ranges\nconst CATEGORY_MULTIPLIERS: Record<string, { low: number; high: number; difficulty: number }> = {\n  electronics: { low: 1.2, high: 1.6, difficulty: 2 },\n  furniture: { low: 1.3, high: 1.8, difficulty: 4 }, // Harder to ship\n  appliances: { low: 1.1, high: 1.4, difficulty: 4 },\n  tools: { low: 1.3, high: 1.7, difficulty: 2 },\n  \"video games\": { low: 1.4, high: 2.0, difficulty: 1 },\n  collectibles: { low: 1.5, high: 2.5, difficulty: 2 },\n  clothing: { low: 1.1, high: 1.5, difficulty: 3 },\n  sports: { low: 1.2, high: 1.6, difficulty: 3 },\n  musical: { low: 1.3, high: 1.7, difficulty: 3 },\n  automotive: { low: 1.1, high: 1.4, difficulty: 4 },\n  default: { low: 1.2, high: 1.5, difficulty: 3 },\n};\n\n// Keywords that indicate higher value items\nconst VALUE_KEYWORDS = [\n  { pattern: /apple|iphone|ipad|macbook|airpods/i, boost: 1.2, label: \"Apple product\", tag: \"apple\" },\n  { pattern: /samsung|galaxy/i, boost: 1.15, label: \"Samsung\", tag: \"samsung\" },\n  { pattern: /sony|playstation|ps5|ps4/i, boost: 1.2, label: \"Sony/PlayStation\", tag: \"sony\" },\n  { pattern: /nintendo|switch/i, boost: 1.25, label: \"Nintendo\", tag: \"nintendo\" },\n  { pattern: /xbox|microsoft/i, boost: 1.15, label: \"Xbox/Microsoft\", tag: \"xbox\" },\n  { pattern: /dyson/i, boost: 1.3, label: \"Dyson\", tag: \"dyson\" },\n  { pattern: /kitchenaid|vitamix/i, boost: 1.25, label: \"Premium kitchen brand\", tag: \"premium-kitchen\" },\n  { pattern: /herman miller|steelcase/i, boost: 1.4, label: \"Premium furniture\", tag: \"premium-furniture\" },\n  { pattern: /pioneer|ddj/i, boost: 1.2, label: \"DJ equipment\", tag: \"dj-equipment\" },\n  { pattern: /vintage|antique|retro/i, boost: 1.4, label: \"Vintage/collectible\", tag: \"vintage\" },\n  { pattern: /sealed|new in box|nib|bnib/i, boost: 1.3, label: \"New/sealed condition\", tag: \"sealed\" },\n  { pattern: /rare|limited edition/i, boost: 1.4, label: \"Rare/limited\", tag: \"rare\" },\n];\n\n// Keywords that indicate lower value or risk\nconst RISK_KEYWORDS = [\n  { pattern: /broken|damaged|parts only|for parts/i, penalty: 0.3, label: \"For parts only\", tag: \"for-parts\" },\n  { pattern: /needs repair|not working|doesn't work/i, penalty: 0.4, label: \"Needs repair\", tag: \"needs-repair\" },\n  { pattern: /scratched|dented|worn/i, penalty: 0.85, label: \"Cosmetic wear\", tag: \"cosmetic-wear\" },\n  { pattern: /missing|incomplete/i, penalty: 0.6, label: \"Incomplete\", tag: \"incomplete\" },\n  { pattern: /old|used heavily/i, penalty: 0.75, label: \"Heavy use\", tag: \"heavy-use\" },\n];\n\n// Keywords that indicate negotiable pricing\nconst NEGOTIABLE_KEYWORDS = /obo|or best offer|negotiable|make\\s*(an\\s*)?offer|flexible|willing to negotiate|best offer/i;\n\n// Keywords that indicate local pickup only (not shippable)\nconst LOCAL_ONLY_KEYWORDS = /local pickup|pickup only|no shipping|cash only|must pick up|local only|in person/i;\n\n// Condition multipliers\nconst CONDITION_MULTIPLIERS: Record<string, number> = {\n  new: 1.0,\n  \"like new\": 0.92,\n  excellent: 0.85,\n  good: 0.75,\n  fair: 0.6,\n  poor: 0.4,\n};\n\n// Resale difficulty levels\nconst DIFFICULTY_LABELS: Record<number, \"VERY_EASY\" | \"EASY\" | \"MODERATE\" | \"HARD\" | \"VERY_HARD\"> = {\n  1: \"VERY_EASY\",\n  2: \"EASY\",\n  3: \"MODERATE\",\n  4: \"HARD\",\n  5: \"VERY_HARD\",\n};\n\n// Generate search query for a product\nfunction generateSearchQuery(title: string): string {\n  const fillerWords = /\\b(the|a|an|and|or|for|with|in|on|at|to|of|is|it|this|that|will|can|be|has|have|was|are|were|just|very|really|new|used|great|good|nice|excellent|condition)\\b/gi;\n  let query = title.replace(fillerWords, \" \").replace(/\\s+/g, \" \").trim();\n  const words = query.split(\" \").filter((w) => w.length > 2).slice(0, 6);\n  return words.join(\" \");\n}\n\n// Generate eBay sold listings URL\nfunction getEbaySoldUrl(title: string): string {\n  const query = encodeURIComponent(generateSearchQuery(title));\n  return `https://www.ebay.com/sch/i.html?_nkw=${query}&LH_Complete=1&LH_Sold=1&_sop=13`;\n}\n\n// Generate eBay active listings URL\nfunction getEbayActiveUrl(title: string): string {\n  const query = encodeURIComponent(generateSearchQuery(title));\n  return `https://www.ebay.com/sch/i.html?_nkw=${query}&_sop=15`;\n}\n\n// Generate Facebook Marketplace search URL\nfunction getFacebookMarketplaceUrl(title: string): string {\n  const query = encodeURIComponent(generateSearchQuery(title));\n  return `https://www.facebook.com/marketplace/search/?query=${query}`;\n}\n\n// Generate Mercari search URL\nfunction getMercariUrl(title: string): string {\n  const query = encodeURIComponent(generateSearchQuery(title));\n  return `https://www.mercari.com/search/?keyword=${query}`;\n}\n\nexport function estimateValue(\n  title: string,\n  description: string | null,\n  askingPrice: number,\n  condition: string | null,\n  category: string | null\n): EstimationResult {\n  const fullText = `${title} ${description || \"\"}`.toLowerCase();\n\n  // Get category multiplier range\n  const categoryKey = category?.toLowerCase() || \"default\";\n  const categoryData = CATEGORY_MULTIPLIERS[categoryKey] || CATEGORY_MULTIPLIERS.default;\n\n  // Apply condition multiplier\n  const conditionKey = condition?.toLowerCase() || \"good\";\n  const conditionMultiplier = CONDITION_MULTIPLIERS[conditionKey] || 0.75;\n\n  // Check for value-adding keywords\n  let valueBoost = 1.0;\n  const valueMatches: string[] = [];\n  const tags: string[] = [categoryKey];\n\n  for (const { pattern, boost, label, tag } of VALUE_KEYWORDS) {\n    if (pattern.test(fullText)) {\n      valueBoost *= boost;\n      valueMatches.push(label);\n      tags.push(tag);\n    }\n  }\n\n  // Check for risk keywords\n  let riskPenalty = 1.0;\n  const riskMatches: string[] = [];\n  let difficultyAdjust = 0;\n\n  for (const { pattern, penalty, label, tag } of RISK_KEYWORDS) {\n    if (pattern.test(fullText)) {\n      riskPenalty *= penalty;\n      riskMatches.push(label);\n      tags.push(tag);\n      difficultyAdjust += 1;\n    }\n  }\n\n  // Check if negotiable\n  const negotiable = NEGOTIABLE_KEYWORDS.test(fullText);\n  if (negotiable) tags.push(\"negotiable\");\n\n  // Check if shippable\n  const shippable = !LOCAL_ONLY_KEYWORDS.test(fullText);\n  if (!shippable) {\n    tags.push(\"local-only\");\n    difficultyAdjust += 1;\n  }\n\n  // Calculate estimated market value range\n  const baseLow = askingPrice * categoryData.low * conditionMultiplier * valueBoost * riskPenalty;\n  const baseHigh = askingPrice * categoryData.high * conditionMultiplier * valueBoost * riskPenalty;\n\n  const estimatedLow = Math.round(baseLow);\n  const estimatedHigh = Math.round(baseHigh);\n  const estimatedValue = Math.round((baseLow + baseHigh) / 2);\n\n  // Calculate discount percentage (how far below market value)\n  const discountPercent = Math.round(((estimatedValue - askingPrice) / estimatedValue) * 100);\n\n  // Calculate profit potential (accounting for ~13% platform fees on eBay/Mercari)\n  const feeRate = 0.13;\n  const profitLow = Math.round(estimatedLow * (1 - feeRate) - askingPrice);\n  const profitHigh = Math.round(estimatedHigh * (1 - feeRate) - askingPrice);\n  const profitPotential = Math.round((profitLow + profitHigh) / 2);\n\n  // Calculate value score (0-100)\n  const profitMargin = profitPotential / askingPrice;\n  let valueScore = Math.min(100, Math.max(0, Math.round(profitMargin * 100 + 50)));\n\n  // Adjust score based on absolute profit\n  if (profitPotential < 10) valueScore = Math.min(valueScore, 30);\n  if (profitPotential < 0) valueScore = Math.min(valueScore, 10);\n  if (profitPotential > 100) valueScore = Math.min(100, valueScore + 10);\n  if (profitPotential > 200) valueScore = Math.min(100, valueScore + 10);\n\n  // Calculate resale difficulty\n  let difficultyLevel = categoryData.difficulty + difficultyAdjust;\n  if (valueMatches.length > 0) difficultyLevel -= 1; // Known brands are easier\n  difficultyLevel = Math.max(1, Math.min(5, difficultyLevel));\n  const resaleDifficulty = DIFFICULTY_LABELS[difficultyLevel];\n\n  // Determine confidence level\n  let confidence: \"low\" | \"medium\" | \"high\" = \"medium\";\n  if (valueMatches.length > 0 && riskMatches.length === 0) {\n    confidence = \"high\";\n  } else if (riskMatches.length > 0) {\n    confidence = \"low\";\n  }\n\n  // Generate reasoning\n  const reasons: string[] = [];\n  reasons.push(`IMPORTANT: These are algorithmic estimates. Check the reference links for actual sold prices.`);\n  reasons.push(`Category: ${categoryKey} (${categoryData.low}x - ${categoryData.high}x markup)`);\n  reasons.push(`Condition factor: ${conditionMultiplier}x`);\n  if (valueMatches.length > 0) {\n    reasons.push(`Value indicators: ${valueMatches.join(\", \")}`);\n  }\n  if (riskMatches.length > 0) {\n    reasons.push(`Risk factors: ${riskMatches.join(\", \")}`);\n  }\n  reasons.push(`Platform fees estimated at 13%`);\n\n  // Generate notes (AI-style analysis)\n  const notes: string[] = [];\n  if (valueMatches.length > 0) {\n    notes.push(`${valueMatches.join(\" and \")} detected - typically holds value well.`);\n  }\n  if (discountPercent >= 50) {\n    notes.push(`Listed at ${discountPercent}% below estimated market value - strong flip potential.`);\n  } else if (discountPercent >= 30) {\n    notes.push(`Decent discount at ${discountPercent}% below market.`);\n  }\n  if (negotiable) {\n    notes.push(`Price appears negotiable - could get better deal.`);\n  }\n  if (!shippable) {\n    notes.push(`Local pickup only - limits resale options to local platforms.`);\n  }\n  if (riskMatches.length > 0) {\n    notes.push(`Caution: ${riskMatches.join(\", \")} - factor into resale price.`);\n  }\n  if (notes.length === 0) {\n    notes.push(`Standard listing with average flip potential.`);\n  }\n\n  // Generate comparable URLs\n  const comparableUrls: ComparableUrl[] = [\n    {\n      platform: \"eBay\",\n      label: \"eBay Sold Listings (verify actual prices here!)\",\n      url: getEbaySoldUrl(title),\n      type: \"sold\",\n    },\n    {\n      platform: \"eBay\",\n      label: \"eBay Active Listings\",\n      url: getEbayActiveUrl(title),\n      type: \"active\",\n    },\n    {\n      platform: \"Facebook\",\n      label: \"Facebook Marketplace\",\n      url: getFacebookMarketplaceUrl(title),\n      type: \"search\",\n    },\n    {\n      platform: \"Mercari\",\n      label: \"Mercari Listings\",\n      url: getMercariUrl(title),\n      type: \"search\",\n    },\n  ];\n\n  return {\n    estimatedValue,\n    estimatedLow,\n    estimatedHigh,\n    profitPotential,\n    profitLow,\n    profitHigh,\n    valueScore,\n    discountPercent,\n    resaleDifficulty,\n    confidence,\n    reasoning: reasons.join(\" | \"),\n    notes: notes.join(\" \"),\n    comparableUrls,\n    shippable,\n    negotiable,\n    tags,\n  };\n}\n\n// Generate a purchase request message to send to seller\nexport function generatePurchaseMessage(\n  title: string,\n  askingPrice: number,\n  negotiable: boolean,\n  sellerName?: string | null\n): string {\n  const greeting = sellerName ? `Hi ${sellerName},` : \"Hi,\";\n  const itemRef = title.length > 50 ? title.substring(0, 47) + \"...\" : title;\n\n  if (negotiable) {\n    // Offer slightly below asking if negotiable\n    const offerPrice = Math.round(askingPrice * 0.85);\n    return `${greeting}\n\nI'm interested in your ${itemRef} listing. Is this item still available?\n\nWould you consider $${offerPrice} for it? I can pick up today/tomorrow and pay cash.\n\nThanks!`;\n  } else {\n    return `${greeting}\n\nI'm interested in your ${itemRef} listing for $${askingPrice}. Is this item still available?\n\nI can pick up at your convenience and pay cash. Please let me know!\n\nThanks!`;\n  }\n}\n\n// Determine the best category based on title/description\nexport function detectCategory(title: string, description: string | null): string {\n  const fullText = `${title} ${description || \"\"}`.toLowerCase();\n\n  const categoryPatterns: [string, RegExp][] = [\n    // Musical first - DJ equipment and instruments (before video games due to \"controller\")\n    [\"musical\", /guitar|piano|keyboard|drum|amp|amplifier|instrument|dj\\b|ddj|pioneer\\s*ddj/],\n    // Video games next - consoles and gaming (before electronics due to \"console\", \"controller\")\n    [\"video games\", /playstation|xbox|nintendo|game\\b|ps5|ps4|switch|wii/],\n    // Electronics - general tech items\n    [\"electronics\", /phone|ipad|laptop|computer|tablet|tv|monitor|camera|speaker|headphone|gaming|console/],\n    [\"furniture\", /couch|sofa|table|chair|desk|bed|dresser|cabinet|shelf/],\n    [\"appliances\", /washer|dryer|refrigerator|fridge|dishwasher|microwave|oven|vacuum/],\n    [\"tools\", /drill|saw|wrench|hammer|power tool|dewalt|milwaukee|makita/],\n    [\"collectibles\", /vintage|antique|collectible|rare|limited|comic|card|coin/],\n    [\"clothing\", /shirt|pants|dress|shoes|jacket|coat|clothing|fashion/],\n    [\"sports\", /bike|bicycle|golf|tennis|fitness|gym|weights|treadmill/],\n    [\"automotive\", /car|truck|motorcycle|parts|tire|wheel|engine/],\n  ];\n\n  for (const [category, pattern] of categoryPatterns) {\n    if (pattern.test(fullText)) {\n      return category;\n    }\n  }\n\n  return \"other\";\n}\n"],"names":[],"mappings":"AAAA,gDAAgD;AAChD,mFAAmF;;;;;;;;;AA4BnF,8DAA8D;AAC9D,MAAM,uBAA0F;IAC9F,aAAa;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAClD,WAAW;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAChD,YAAY;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IACjD,OAAO;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAC5C,eAAe;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IACpD,cAAc;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IACnD,UAAU;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAC/C,QAAQ;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAC7C,SAAS;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IAC9C,YAAY;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;IACjD,SAAS;QAAE,KAAK;QAAK,MAAM;QAAK,YAAY;IAAE;AAChD;AAEA,4CAA4C;AAC5C,MAAM,iBAAiB;IACrB;QAAE,SAAS;QAAsC,OAAO;QAAK,OAAO;QAAiB,KAAK;IAAQ;IAClG;QAAE,SAAS;QAAmB,OAAO;QAAM,OAAO;QAAW,KAAK;IAAU;IAC5E;QAAE,SAAS;QAA6B,OAAO;QAAK,OAAO;QAAoB,KAAK;IAAO;IAC3F;QAAE,SAAS;QAAoB,OAAO;QAAM,OAAO;QAAY,KAAK;IAAW;IAC/E;QAAE,SAAS;QAAmB,OAAO;QAAM,OAAO;QAAkB,KAAK;IAAO;IAChF;QAAE,SAAS;QAAU,OAAO;QAAK,OAAO;QAAS,KAAK;IAAQ;IAC9D;QAAE,SAAS;QAAuB,OAAO;QAAM,OAAO;QAAyB,KAAK;IAAkB;IACtG;QAAE,SAAS;QAA4B,OAAO;QAAK,OAAO;QAAqB,KAAK;IAAoB;IACxG;QAAE,SAAS;QAAgB,OAAO;QAAK,OAAO;QAAgB,KAAK;IAAe;IAClF;QAAE,SAAS;QAA0B,OAAO;QAAK,OAAO;QAAuB,KAAK;IAAU;IAC9F;QAAE,SAAS;QAA+B,OAAO;QAAK,OAAO;QAAwB,KAAK;IAAS;IACnG;QAAE,SAAS;QAAyB,OAAO;QAAK,OAAO;QAAgB,KAAK;IAAO;CACpF;AAED,6CAA6C;AAC7C,MAAM,gBAAgB;IACpB;QAAE,SAAS;QAAwC,SAAS;QAAK,OAAO;QAAkB,KAAK;IAAY;IAC3G;QAAE,SAAS;QAA0C,SAAS;QAAK,OAAO;QAAgB,KAAK;IAAe;IAC9G;QAAE,SAAS;QAA0B,SAAS;QAAM,OAAO;QAAiB,KAAK;IAAgB;IACjG;QAAE,SAAS;QAAuB,SAAS;QAAK,OAAO;QAAc,KAAK;IAAa;IACvF;QAAE,SAAS;QAAqB,SAAS;QAAM,OAAO;QAAa,KAAK;IAAY;CACrF;AAED,4CAA4C;AAC5C,MAAM,sBAAsB;AAE5B,2DAA2D;AAC3D,MAAM,sBAAsB;AAE5B,wBAAwB;AACxB,MAAM,wBAAgD;IACpD,KAAK;IACL,YAAY;IACZ,WAAW;IACX,MAAM;IACN,MAAM;IACN,MAAM;AACR;AAEA,2BAA2B;AAC3B,MAAM,oBAA8F;IAClG,GAAG;IACH,GAAG;IACH,GAAG;IACH,GAAG;IACH,GAAG;AACL;AAEA,sCAAsC;AACtC,SAAS,oBAAoB,KAAa;IACxC,MAAM,cAAc;IACpB,IAAI,QAAQ,MAAM,OAAO,CAAC,aAAa,KAAK,OAAO,CAAC,QAAQ,KAAK,IAAI;IACrE,MAAM,QAAQ,MAAM,KAAK,CAAC,KAAK,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG;IACpE,OAAO,MAAM,IAAI,CAAC;AACpB;AAEA,kCAAkC;AAClC,SAAS,eAAe,KAAa;IACnC,MAAM,QAAQ,mBAAmB,oBAAoB;IACrD,OAAO,CAAC,qCAAqC,EAAE,MAAM,gCAAgC,CAAC;AACxF;AAEA,oCAAoC;AACpC,SAAS,iBAAiB,KAAa;IACrC,MAAM,QAAQ,mBAAmB,oBAAoB;IACrD,OAAO,CAAC,qCAAqC,EAAE,MAAM,QAAQ,CAAC;AAChE;AAEA,2CAA2C;AAC3C,SAAS,0BAA0B,KAAa;IAC9C,MAAM,QAAQ,mBAAmB,oBAAoB;IACrD,OAAO,CAAC,mDAAmD,EAAE,OAAO;AACtE;AAEA,8BAA8B;AAC9B,SAAS,cAAc,KAAa;IAClC,MAAM,QAAQ,mBAAmB,oBAAoB;IACrD,OAAO,CAAC,wCAAwC,EAAE,OAAO;AAC3D;AAEO,SAAS,cACd,KAAa,EACb,WAA0B,EAC1B,WAAmB,EACnB,SAAwB,EACxB,QAAuB;IAEvB,MAAM,WAAW,GAAG,MAAM,CAAC,EAAE,eAAe,IAAI,CAAC,WAAW;IAE5D,gCAAgC;IAChC,MAAM,cAAc,UAAU,iBAAiB;IAC/C,MAAM,eAAe,oBAAoB,CAAC,YAAY,IAAI,qBAAqB,OAAO;IAEtF,6BAA6B;IAC7B,MAAM,eAAe,WAAW,iBAAiB;IACjD,MAAM,sBAAsB,qBAAqB,CAAC,aAAa,IAAI;IAEnE,kCAAkC;IAClC,IAAI,aAAa;IACjB,MAAM,eAAyB,EAAE;IACjC,MAAM,OAAiB;QAAC;KAAY;IAEpC,KAAK,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,eAAgB;QAC3D,IAAI,QAAQ,IAAI,CAAC,WAAW;YAC1B,cAAc;YACd,aAAa,IAAI,CAAC;YAClB,KAAK,IAAI,CAAC;QACZ;IACF;IAEA,0BAA0B;IAC1B,IAAI,cAAc;IAClB,MAAM,cAAwB,EAAE;IAChC,IAAI,mBAAmB;IAEvB,KAAK,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,cAAe;QAC5D,IAAI,QAAQ,IAAI,CAAC,WAAW;YAC1B,eAAe;YACf,YAAY,IAAI,CAAC;YACjB,KAAK,IAAI,CAAC;YACV,oBAAoB;QACtB;IACF;IAEA,sBAAsB;IACtB,MAAM,aAAa,oBAAoB,IAAI,CAAC;IAC5C,IAAI,YAAY,KAAK,IAAI,CAAC;IAE1B,qBAAqB;IACrB,MAAM,YAAY,CAAC,oBAAoB,IAAI,CAAC;IAC5C,IAAI,CAAC,WAAW;QACd,KAAK,IAAI,CAAC;QACV,oBAAoB;IACtB;IAEA,yCAAyC;IACzC,MAAM,UAAU,cAAc,aAAa,GAAG,GAAG,sBAAsB,aAAa;IACpF,MAAM,WAAW,cAAc,aAAa,IAAI,GAAG,sBAAsB,aAAa;IAEtF,MAAM,eAAe,KAAK,KAAK,CAAC;IAChC,MAAM,gBAAgB,KAAK,KAAK,CAAC;IACjC,MAAM,iBAAiB,KAAK,KAAK,CAAC,CAAC,UAAU,QAAQ,IAAI;IAEzD,6DAA6D;IAC7D,MAAM,kBAAkB,KAAK,KAAK,CAAC,AAAC,CAAC,iBAAiB,WAAW,IAAI,iBAAkB;IAEvF,iFAAiF;IACjF,MAAM,UAAU;IAChB,MAAM,YAAY,KAAK,KAAK,CAAC,eAAe,CAAC,IAAI,OAAO,IAAI;IAC5D,MAAM,aAAa,KAAK,KAAK,CAAC,gBAAgB,CAAC,IAAI,OAAO,IAAI;IAC9D,MAAM,kBAAkB,KAAK,KAAK,CAAC,CAAC,YAAY,UAAU,IAAI;IAE9D,gCAAgC;IAChC,MAAM,eAAe,kBAAkB;IACvC,IAAI,aAAa,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,eAAe,MAAM;IAE3E,wCAAwC;IACxC,IAAI,kBAAkB,IAAI,aAAa,KAAK,GAAG,CAAC,YAAY;IAC5D,IAAI,kBAAkB,GAAG,aAAa,KAAK,GAAG,CAAC,YAAY;IAC3D,IAAI,kBAAkB,KAAK,aAAa,KAAK,GAAG,CAAC,KAAK,aAAa;IACnE,IAAI,kBAAkB,KAAK,aAAa,KAAK,GAAG,CAAC,KAAK,aAAa;IAEnE,8BAA8B;IAC9B,IAAI,kBAAkB,aAAa,UAAU,GAAG;IAChD,IAAI,aAAa,MAAM,GAAG,GAAG,mBAAmB,GAAG,0BAA0B;IAC7E,kBAAkB,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG;IAC1C,MAAM,mBAAmB,iBAAiB,CAAC,gBAAgB;IAE3D,6BAA6B;IAC7B,IAAI,aAAwC;IAC5C,IAAI,aAAa,MAAM,GAAG,KAAK,YAAY,MAAM,KAAK,GAAG;QACvD,aAAa;IACf,OAAO,IAAI,YAAY,MAAM,GAAG,GAAG;QACjC,aAAa;IACf;IAEA,qBAAqB;IACrB,MAAM,UAAoB,EAAE;IAC5B,QAAQ,IAAI,CAAC,CAAC,6FAA6F,CAAC;IAC5G,QAAQ,IAAI,CAAC,CAAC,UAAU,EAAE,YAAY,EAAE,EAAE,aAAa,GAAG,CAAC,IAAI,EAAE,aAAa,IAAI,CAAC,SAAS,CAAC;IAC7F,QAAQ,IAAI,CAAC,CAAC,kBAAkB,EAAE,oBAAoB,CAAC,CAAC;IACxD,IAAI,aAAa,MAAM,GAAG,GAAG;QAC3B,QAAQ,IAAI,CAAC,CAAC,kBAAkB,EAAE,aAAa,IAAI,CAAC,OAAO;IAC7D;IACA,IAAI,YAAY,MAAM,GAAG,GAAG;QAC1B,QAAQ,IAAI,CAAC,CAAC,cAAc,EAAE,YAAY,IAAI,CAAC,OAAO;IACxD;IACA,QAAQ,IAAI,CAAC,CAAC,8BAA8B,CAAC;IAE7C,qCAAqC;IACrC,MAAM,QAAkB,EAAE;IAC1B,IAAI,aAAa,MAAM,GAAG,GAAG;QAC3B,MAAM,IAAI,CAAC,GAAG,aAAa,IAAI,CAAC,SAAS,uCAAuC,CAAC;IACnF;IACA,IAAI,mBAAmB,IAAI;QACzB,MAAM,IAAI,CAAC,CAAC,UAAU,EAAE,gBAAgB,uDAAuD,CAAC;IAClG,OAAO,IAAI,mBAAmB,IAAI;QAChC,MAAM,IAAI,CAAC,CAAC,mBAAmB,EAAE,gBAAgB,eAAe,CAAC;IACnE;IACA,IAAI,YAAY;QACd,MAAM,IAAI,CAAC,CAAC,iDAAiD,CAAC;IAChE;IACA,IAAI,CAAC,WAAW;QACd,MAAM,IAAI,CAAC,CAAC,6DAA6D,CAAC;IAC5E;IACA,IAAI,YAAY,MAAM,GAAG,GAAG;QAC1B,MAAM,IAAI,CAAC,CAAC,SAAS,EAAE,YAAY,IAAI,CAAC,MAAM,4BAA4B,CAAC;IAC7E;IACA,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,MAAM,IAAI,CAAC,CAAC,6CAA6C,CAAC;IAC5D;IAEA,2BAA2B;IAC3B,MAAM,iBAAkC;QACtC;YACE,UAAU;YACV,OAAO;YACP,KAAK,eAAe;YACpB,MAAM;QACR;QACA;YACE,UAAU;YACV,OAAO;YACP,KAAK,iBAAiB;YACtB,MAAM;QACR;QACA;YACE,UAAU;YACV,OAAO;YACP,KAAK,0BAA0B;YAC/B,MAAM;QACR;QACA;YACE,UAAU;YACV,OAAO;YACP,KAAK,cAAc;YACnB,MAAM;QACR;KACD;IAED,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,WAAW,QAAQ,IAAI,CAAC;QACxB,OAAO,MAAM,IAAI,CAAC;QAClB;QACA;QACA;QACA;IACF;AACF;AAGO,SAAS,wBACd,KAAa,EACb,WAAmB,EACnB,UAAmB,EACnB,UAA0B;IAE1B,MAAM,WAAW,aAAa,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC,GAAG;IACpD,MAAM,UAAU,MAAM,MAAM,GAAG,KAAK,MAAM,SAAS,CAAC,GAAG,MAAM,QAAQ;IAErE,IAAI,YAAY;QACd,4CAA4C;QAC5C,MAAM,aAAa,KAAK,KAAK,CAAC,cAAc;QAC5C,OAAO,GAAG,SAAS;;uBAEA,EAAE,QAAQ;;oBAEb,EAAE,WAAW;;OAE1B,CAAC;IACN,OAAO;QACL,OAAO,GAAG,SAAS;;uBAEA,EAAE,QAAQ,cAAc,EAAE,YAAY;;;;OAItD,CAAC;IACN;AACF;AAGO,SAAS,eAAe,KAAa,EAAE,WAA0B;IACtE,MAAM,WAAW,GAAG,MAAM,CAAC,EAAE,eAAe,IAAI,CAAC,WAAW;IAE5D,MAAM,mBAAuC;QAC3C,wFAAwF;QACxF;YAAC;YAAW;SAA6E;QACzF,6FAA6F;QAC7F;YAAC;YAAe;SAAsD;QACtE,mCAAmC;QACnC;YAAC;YAAe;SAAuF;QACvG;YAAC;YAAa;SAAwD;QACtE;YAAC;YAAc;SAAoE;QACnF;YAAC;YAAS;SAA6D;QACvE;YAAC;YAAgB;SAA2D;QAC5E;YAAC;YAAY;SAAuD;QACpE;YAAC;YAAU;SAAyD;QACpE;YAAC;YAAc;SAA+C;KAC/D;IAED,KAAK,MAAM,CAAC,UAAU,QAAQ,IAAI,iBAAkB;QAClD,IAAI,QAAQ,IAAI,CAAC,WAAW;YAC1B,OAAO;QACT;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 871, "column": 0}, "map": {"version":3,"sources":["file:///Users/stephenboyett/Desktop/Github/axovia-ai/flipper-ai/src/app/api/scraper/craigslist/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { chromium } from \"playwright\";\nimport prisma from \"@/lib/db\";\nimport { estimateValue, detectCategory, generatePurchaseMessage } from \"@/lib/value-estimator\";\n\ninterface CraigslistItem {\n  title: string;\n  price: number;\n  url: string;\n  location: string;\n  externalId: string;\n  description?: string;\n  imageUrls?: string[];\n  postedAt?: Date;\n}\n\n// Parse price from Craigslist format\nfunction parsePrice(priceStr: string): number {\n  const match = priceStr.match(/\\$?([\\d,]+)/);\n  if (match) {\n    return parseFloat(match[1].replace(/,/g, \"\"));\n  }\n  return 0;\n}\n\n// Extract listing ID from URL\nfunction extractListingId(url: string): string {\n  const match = url.match(/\\/(\\d+)\\.html/);\n  return match ? match[1] : url;\n}\n\n// Category mapping to Craigslist paths\nconst categoryPaths: Record<string, string> = {\n  electronics: \"ela\",\n  furniture: \"fua\",\n  appliances: \"ppa\",\n  sporting: \"sga\",\n  tools: \"tla\",\n  jewelry: \"jwa\",\n  antiques: \"ata\",\n  video_gaming: \"vga\",\n  music_instr: \"msa\",\n  computers: \"sya\",\n  cell_phones: \"moa\",\n};\n\n// Scrape Craigslist using Playwright (real browser)\nasync function scrapeCraigslistWithPlaywright(\n  location: string,\n  category: string,\n  query?: string,\n  minPrice?: number,\n  maxPrice?: number\n): Promise<CraigslistItem[]> {\n  const browser = await chromium.launch({ headless: true });\n  const context = await browser.newContext({\n    userAgent: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n  });\n  const page = await context.newPage();\n\n  try {\n    // Build search URL\n    const baseUrl = `https://${location}.craigslist.org`;\n    const categoryPath = categoryPaths[category] || \"sss\";\n    const searchParams = new URLSearchParams();\n\n    if (query) searchParams.set(\"query\", query);\n    if (minPrice) searchParams.set(\"min_price\", minPrice.toString());\n    if (maxPrice) searchParams.set(\"max_price\", maxPrice.toString());\n\n    const searchUrl = `${baseUrl}/search/${categoryPath}?${searchParams.toString()}`;\n    console.log(`Navigating to: ${searchUrl}`);\n\n    await page.goto(searchUrl, { waitUntil: \"domcontentloaded\", timeout: 30000 });\n\n    // Wait for listings to load\n    await page.waitForSelector(\".cl-search-result, .result-row, .gallery-card, li.cl-static-search-result\", { timeout: 10000 }).catch(() => {\n      console.log(\"No standard listing selector found, trying alternate approach\");\n    });\n\n    // Extract listings using page.evaluate\n    const listings = await page.evaluate(() => {\n      const items: Array<{\n        title: string;\n        price: string;\n        url: string;\n        location: string;\n        imageUrl?: string;\n      }> = [];\n\n      // Try multiple selector patterns (Craigslist UI changes)\n      const selectors = [\n        \".cl-search-result\",\n        \".result-row\",\n        \".gallery-card\",\n        \"li.cl-static-search-result\"\n      ];\n\n      let listingElements: Element[] = [];\n      for (const selector of selectors) {\n        const elements = document.querySelectorAll(selector);\n        if (elements.length > 0) {\n          listingElements = Array.from(elements);\n          break;\n        }\n      }\n\n      // If still no results, try the generic list item approach\n      if (listingElements.length === 0) {\n        listingElements = Array.from(document.querySelectorAll('[data-pid]'));\n      }\n\n      for (const el of listingElements.slice(0, 50)) { // Limit to 50 listings\n        try {\n          // Extract title\n          const titleEl = el.querySelector(\".posting-title, .result-title, .titlestring, a.posting-title, .label\") as HTMLElement;\n          const title = titleEl?.innerText?.trim() || el.querySelector(\"a\")?.innerText?.trim() || \"\";\n\n          // Extract URL\n          const linkEl = el.querySelector(\"a[href*='/']\") as HTMLAnchorElement;\n          const url = linkEl?.href || \"\";\n\n          // Extract price\n          const priceEl = el.querySelector(\".priceinfo, .result-price, .price\") as HTMLElement;\n          const price = priceEl?.innerText?.trim() || \"$0\";\n\n          // Extract location\n          const locationEl = el.querySelector(\".meta, .result-hood, .location, .supertitle\") as HTMLElement;\n          const location = locationEl?.innerText?.replace(/[()]/g, \"\").trim() || \"\";\n\n          // Extract image\n          const imgEl = el.querySelector(\"img\") as HTMLImageElement;\n          const imageUrl = imgEl?.src || \"\";\n\n          if (title && url && !title.includes(\"sponsored\")) {\n            items.push({ title, price, url, location, imageUrl });\n          }\n        } catch (e) {\n          // Skip problematic listings\n        }\n      }\n\n      return items;\n    });\n\n    console.log(`Found ${listings.length} listings`);\n\n    // Convert to our format\n    const results: CraigslistItem[] = listings.map((item) => ({\n      title: item.title,\n      price: parsePrice(item.price),\n      url: item.url,\n      location: item.location || location,\n      externalId: extractListingId(item.url),\n      imageUrls: item.imageUrl ? [item.imageUrl] : undefined,\n    }));\n\n    return results;\n  } finally {\n    await browser.close();\n  }\n}\n\n// POST /api/scraper/craigslist - Run scraper\nexport async function POST(request: NextRequest) {\n  let job = null;\n\n  try {\n    const body = await request.json();\n    const { location, category, keywords, minPrice, maxPrice } = body;\n\n    if (!location || !category) {\n      return NextResponse.json(\n        { success: false, message: \"Location and category are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Create scraper job record\n    job = await prisma.scraperJob.create({\n      data: {\n        platform: \"CRAIGSLIST\",\n        location,\n        category,\n        status: \"RUNNING\",\n        startedAt: new Date(),\n      },\n    });\n\n    // Scrape listings using Playwright\n    const listings = await scrapeCraigslistWithPlaywright(\n      location,\n      category,\n      keywords,\n      minPrice,\n      maxPrice\n    );\n\n    if (listings.length === 0) {\n      // Update job as completed with no results\n      await prisma.scraperJob.update({\n        where: { id: job.id },\n        data: {\n          status: \"COMPLETED\",\n          listingsFound: 0,\n          opportunitiesFound: 0,\n          completedAt: new Date(),\n        },\n      });\n\n      return NextResponse.json({\n        success: true,\n        message: \"No listings found matching your criteria. Try different search parameters.\",\n        listings: [],\n        savedCount: 0,\n        jobId: job.id,\n      });\n    }\n\n    // Save listings to database with value estimation\n    let savedCount = 0;\n    let opportunitiesFound = 0;\n    const savedListings: Array<{\n      title: string;\n      price: string;\n      location: string;\n      url: string;\n      imageUrl?: string;\n    }> = [];\n\n    for (const item of listings) {\n      try {\n        // Skip items without price\n        if (item.price <= 0) continue;\n\n        // Detect category for estimation\n        const detectedCategory = detectCategory(item.title, item.description || null);\n\n        // Estimate value\n        const estimation = estimateValue(\n          item.title,\n          item.description || null,\n          item.price,\n          null, // condition not known\n          detectedCategory\n        );\n\n        // Generate purchase message\n        const requestToBuy = generatePurchaseMessage(\n          item.title,\n          item.price,\n          estimation.negotiable,\n          null\n        );\n\n        // Upsert to database\n        await prisma.listing.upsert({\n          where: {\n            platform_externalId: {\n              platform: \"CRAIGSLIST\",\n              externalId: item.externalId,\n            },\n          },\n          create: {\n            externalId: item.externalId,\n            platform: \"CRAIGSLIST\",\n            url: item.url,\n            title: item.title,\n            description: item.description,\n            askingPrice: item.price,\n            location: item.location,\n            imageUrls: item.imageUrls ? JSON.stringify(item.imageUrls) : null,\n            category: detectedCategory,\n            postedAt: item.postedAt,\n\n            // Value estimation\n            estimatedValue: estimation.estimatedValue,\n            estimatedLow: estimation.estimatedLow,\n            estimatedHigh: estimation.estimatedHigh,\n            profitPotential: estimation.profitPotential,\n            profitLow: estimation.profitLow,\n            profitHigh: estimation.profitHigh,\n            valueScore: estimation.valueScore,\n            discountPercent: estimation.discountPercent,\n            resaleDifficulty: estimation.resaleDifficulty,\n\n            // Market references\n            comparableUrls: JSON.stringify(estimation.comparableUrls),\n            priceReasoning: estimation.reasoning,\n            notes: estimation.notes,\n\n            // Metadata\n            shippable: estimation.shippable,\n            negotiable: estimation.negotiable,\n            tags: JSON.stringify(estimation.tags),\n            requestToBuy,\n\n            // Status\n            status: estimation.valueScore >= 70 ? \"OPPORTUNITY\" : \"NEW\",\n          },\n          update: {\n            title: item.title,\n            description: item.description,\n            askingPrice: item.price,\n            location: item.location,\n            imageUrls: item.imageUrls ? JSON.stringify(item.imageUrls) : null,\n\n            // Update estimation\n            estimatedValue: estimation.estimatedValue,\n            estimatedLow: estimation.estimatedLow,\n            estimatedHigh: estimation.estimatedHigh,\n            profitPotential: estimation.profitPotential,\n            profitLow: estimation.profitLow,\n            profitHigh: estimation.profitHigh,\n            valueScore: estimation.valueScore,\n            discountPercent: estimation.discountPercent,\n            resaleDifficulty: estimation.resaleDifficulty,\n            comparableUrls: JSON.stringify(estimation.comparableUrls),\n            priceReasoning: estimation.reasoning,\n            notes: estimation.notes,\n            shippable: estimation.shippable,\n            negotiable: estimation.negotiable,\n            tags: JSON.stringify(estimation.tags),\n            requestToBuy,\n          },\n        });\n\n        savedCount++;\n        if (estimation.valueScore >= 70) {\n          opportunitiesFound++;\n        }\n        savedListings.push({\n          title: item.title,\n          price: `$${item.price}`,\n          location: item.location,\n          url: item.url,\n          imageUrl: item.imageUrls?.[0],\n        });\n      } catch (error) {\n        console.error(`Error saving listing ${item.externalId}:`, error);\n      }\n    }\n\n    // Update job as completed\n    if (job) {\n      await prisma.scraperJob.update({\n        where: { id: job.id },\n        data: {\n          status: \"COMPLETED\",\n          listingsFound: savedCount,\n          opportunitiesFound,\n          completedAt: new Date(),\n        },\n      });\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: `Successfully scraped ${listings.length} listings`,\n      listings: savedListings,\n      savedCount,\n      opportunitiesFound,\n      jobId: job?.id,\n    });\n  } catch (error) {\n    console.error(\"Scraper error:\", error);\n\n    // Update job as failed\n    if (job) {\n      await prisma.scraperJob.update({\n        where: { id: job.id },\n        data: {\n          status: \"FAILED\",\n          errorMessage: error instanceof Error ? error.message : \"Unknown error\",\n          completedAt: new Date(),\n        },\n      });\n    }\n\n    return NextResponse.json(\n      {\n        success: false,\n        message: \"Failed to scrape listings\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        jobId: job?.id,\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// GET /api/scraper/craigslist - Get scraper status/info\nexport async function GET() {\n  return NextResponse.json({\n    platform: \"craigslist\",\n    status: \"ready\",\n    supportedCategories: Object.keys(categoryPaths),\n    supportedLocations: [\n      \"sarasota\",\n      \"tampa\",\n      \"orlando\",\n      \"miami\",\n      \"jacksonville\",\n      \"sfbay\",\n      \"losangeles\",\n      \"newyork\",\n      \"chicago\",\n      \"seattle\",\n      \"austin\",\n      \"denver\",\n    ],\n  });\n}\n"],"names":[],"mappings":"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"}}]
}