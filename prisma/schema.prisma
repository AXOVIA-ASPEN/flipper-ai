// Flipper.ai Database Schema
// Using SQLite for simple, file-based persistence

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// Marketplace sources we scrape from
enum Platform {
  CRAIGSLIST
  FACEBOOK_MARKETPLACE
  EBAY
  OFFERUP
  MERCARI
}

// Status of a listing in our pipeline
enum ListingStatus {
  NEW           // Just scraped
  ANALYZING     // Calculating flip potential
  OPPORTUNITY   // Good flip opportunity identified
  CONTACTED     // Seller has been contacted
  PURCHASED     // Item purchased
  LISTED        // Re-listed for sale
  SOLD          // Successfully flipped
  PASSED        // Decided to skip
  EXPIRED       // Listing no longer available
}

// Raw listings scraped from marketplaces
model Listing {
  id              String        @id @default(cuid())
  userId          String?       // Owner of this listing (null for legacy/shared data)
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  externalId      String        // Original listing ID from the platform
  platform        String        // CRAIGSLIST, FACEBOOK_MARKETPLACE, EBAY, OFFERUP
  url             String
  title           String
  description     String?
  askingPrice     Float
  condition       String?
  location        String?
  sellerName      String?
  sellerContact   String?
  imageUrls       String?       // JSON array of image URLs
  category        String?
  postedAt        DateTime?
  scrapedAt       DateTime      @default(now())

  // Flip analysis
  estimatedValue  Float?        // What we think it's worth (midpoint)
  estimatedLow    Float?        // Low end of estimated value range
  estimatedHigh   Float?        // High end of estimated value range
  profitPotential Float?        // Estimated profit if flipped
  profitLow       Float?        // Low end profit estimate
  profitHigh      Float?        // High end profit estimate
  valueScore      Float?        // 0-100 score of flip potential
  discountPercent Float?        // How far below market value (e.g., 40 = 40% below)
  resaleDifficulty String?      // VERY_EASY, EASY, MODERATE, HARD, VERY_HARD
  status          String        @default("NEW")

  // Market references (JSON)
  comparableUrls  String?       // JSON: URLs to eBay sold listings, etc.
  priceReasoning  String?       // Explanation of how value was estimated
  notes           String?       // AI-generated analysis notes

  // Additional metadata for flipping
  shippable       Boolean?      // Can be shipped (vs local pickup only)
  estimatedWeight Float?        // Estimated weight in lbs (for shipping cost)
  negotiable      Boolean?      // Is price negotiable? (detected from OBO, firm, etc.)
  daysListed      Int?          // Days since originally posted
  tags            String?       // JSON: Array of detected keywords for filtering

  // AI-generated purchase request message
  requestToBuy    String?       // AI-generated message to send to seller

  // LLM Item Identification
  identifiedBrand     String?   // Brand identified by LLM
  identifiedModel     String?   // Model identified by LLM
  identifiedVariant   String?   // Variant/specs (256GB, Blue, etc.)
  identifiedCondition String?   // Condition assessed by LLM

  // Verified Market Data
  verifiedMarketValue Float?    // True market value from eBay sold data
  marketDataSource    String?   // "ebay_scrape", "ebay_api", etc.
  marketDataDate      DateTime? // When market data was fetched
  comparableSalesJson String?   // JSON array of actual sold listings

  // LLM Sellability Analysis
  sellabilityScore    Int?      // 0-100 sellability score
  demandLevel         String?   // "low", "medium", "high", "very_high"
  expectedDaysToSell  Int?      // Estimated days to sell
  authenticityRisk    String?   // "low", "medium", "high"
  recommendedOffer    Float?    // What to offer the seller
  recommendedList     Float?    // What to list it for on resale
  resaleStrategy      String?   // LLM-generated resale strategy

  // True discount (verified vs algorithmic)
  trueDiscountPercent Float?    // Actual discount based on verified market data

  // Analysis metadata
  llmAnalyzed         Boolean   @default(false)
  analysisDate        DateTime?
  analysisConfidence  String?   // "low", "medium", "high"
  analysisReasoning   String?   // LLM explanation of assessment

  // Relations
  opportunity     Opportunity?

  // Indexes
  @@unique([platform, externalId, userId])
  @@index([userId])
  @@index([platform])
  @@index([status])
  @@index([valueScore])
  @@index([scrapedAt])
  @@index([llmAnalyzed])
  @@index([trueDiscountPercent])
}

// Flip opportunities we're actively pursuing
model Opportunity {
  id              String        @id @default(cuid())
  userId          String?       // Owner of this opportunity
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  listingId       String        @unique
  listing         Listing       @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Purchase info
  purchasePrice   Float?
  purchaseDate    DateTime?
  purchaseNotes   String?

  // Resale info
  resalePrice     Float?
  resalePlatform  String?
  resaleUrl       String?
  resaleDate      DateTime?

  // Profit tracking
  actualProfit    Float?
  fees            Float?        // Platform fees, shipping, etc.

  // Status
  status          String        @default("IDENTIFIED")
  notes           String?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// Scraper job runs
model ScraperJob {
  id              String        @id @default(cuid())
  userId          String?       // User who triggered the scrape
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  platform        String
  location        String?
  category        String?
  status          String        @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED
  listingsFound   Int           @default(0)
  opportunitiesFound Int        @default(0)
  errorMessage    String?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime      @default(now())

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// Search configurations for automated scraping
model SearchConfig {
  id              String        @id @default(cuid())
  userId          String?       // Owner of this config
  user            User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  name            String
  platform        String
  location        String
  category        String?
  keywords        String?       // Comma-separated keywords
  minPrice        Float?
  maxPrice        Float?
  enabled         Boolean       @default(true)
  lastRun         DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([userId])
  @@index([enabled])
}

// Price history for market value estimation
model PriceHistory {
  id              String        @id @default(cuid())
  productName     String
  category        String?
  platform        String
  soldPrice       Float
  condition       String?
  soldAt          DateTime
  createdAt       DateTime      @default(now())

  @@index([productName])
  @@index([category])
}

// NextAuth.js User model
model User {
  id              String        @id @default(cuid())
  email           String        @unique
  emailVerified   DateTime?
  name            String?
  image           String?
  password        String?       // Hashed password for credentials auth
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // NextAuth.js relations
  accounts        Account[]
  sessions        Session[]

  // App-specific relations
  settings        UserSettings?
  listings        Listing[]
  opportunities   Opportunity[]
  scraperJobs     ScraperJob[]
  searchConfigs   SearchConfig[]
}

// NextAuth.js Account model (for OAuth providers)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// NextAuth.js Session model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// NextAuth.js VerificationToken model (for email verification)
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// User settings including API keys for LLM analysis
model UserSettings {
  id                  String    @id @default(cuid())
  userId              String    @unique
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // API Keys (encrypted at rest)
  openaiApiKey        String?   // Encrypted OpenAI API key

  // LLM Preferences
  llmModel            String    @default("gpt-4o-mini")

  // Analysis Preferences
  discountThreshold   Int       @default(50)  // Minimum discount % to flag as opportunity
  autoAnalyze         Boolean   @default(true) // Auto-analyze new listings with LLM

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}

// Facebook OAuth tokens for Marketplace API access
model FacebookToken {
  id              String    @id @default(cuid())
  userId          String    @unique
  accessToken     String    // Encrypted OAuth access token
  expiresAt       DateTime  // Token expiration timestamp
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
  @@index([expiresAt])
}

// AI Analysis Cache (for Claude/LLM responses)
model AiAnalysisCache {
  id              String    @id @default(cuid())
  listingId       String
  analysisResult  String    // JSON-encoded ClaudeAnalysisResult
  createdAt       DateTime  @default(now())
  expiresAt       DateTime

  @@index([listingId])
  @@index([expiresAt])
}
